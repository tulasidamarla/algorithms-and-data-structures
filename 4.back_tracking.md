<h3>Brute Force approach</h3>

 - Finds all the possible solutions and selects desired solution as per the problem statement.

<h3>Backtracking</h3>

 - Backtracking is a problem solving strategy that is sort of refined brute force approach
 - Backtracking systematically searches for a solution to the problem among all avaiable options
 - Backtracking allows us to deal with situations in which a raw brute-force approach would explode into an impossible number of options to consider.
 - At each node, we eliminate choices that are obviously not possible and proceed to recursively check only those that have potential.
 - Usually followed in Dynamic programming, but in dynamic programming we find optimum solution whereas backtracking is used to find all possible solutions.
 - Solutions to the Backtracking problems can be represented as State-Space Tree.
 - The constraint applied to find the solution is called <b>Bounding function.</b>
 
<ins>Note</ins>
 - Backtracking follows Depth-First Search method.
 - Branch and Bound is also a Brute Force approach similar to Backtracking, but uses Breadth-First Search method.

<b>Consider the below problem</b>

 There are 3 students in a class 2 boys and a girl. There are 3 chairs. Find all possible arrangements for 3 students.

 Solution: As we know the answer of arranging n students is n!, so in this case there should be 3! solutions i.e. 6.

		      Root
		  /     |     \   
		 B1      B2     G1    
		/ \     / \     / \   
	       B2  G1   B1  G1  B1  B2 
	       |    |   |   |    |   |  
	       G1   B2  G1  B1   B2  B1

 The above solution used brute force approach with DFS(depth first search) to find all solutions.
 
 Now lets consider another problem to find all possible solutions in which girl should not be in the middle, then backtracking improvizes on brute-force.

 With backtracking, we start with one possible option out of many available options and try to solve the problem. If we are able to solve the problem with the selected move then we will print the solution else we will backtrack and select some other option and try to solve it.

 For ex, if we start with B1, the next option could be B2 and G1. We will not choose G1, because girl should not be in the middle. For this constraint to not choose G1 at level 2, we use bounding function. Using this approach, it skips the nodes that appear at level finds all other possible solutions.

 <ins>Note:</ins>  
 we have skippied visiting two nodes compared to visiting all nodes. This is the gain over brute-force where we visit all the nodes.


		      Root
		  /     |     \   
		 B1     B2     G1    
		/       |      / \   
	       B2      B1     B1   B2 
	       |        |      |   |  
	       G1      G1     B2   B1
	       
<b>Problems</b>

<b>Print all subsets using brute-force</b>

	static void printAllSubSets(char[] array) {

		int length = array.length;
		//(1 << length) is 2^length
		for(int i= 0; i < (1 << length); i++) { // 2^n times
			System.out.print("{ ");
			
			for(int j= 0; j < length; j++ ) { // n times
				iterations++;
				//1 << j gives 1, 10, 100, 1000 so on depends on n
				if((i & (1 << j)) > 0) {
					
					System.out.print(" " + array[j]);
				}
				
			}
			count++;
			System.out.print(" }");
			System.out.println();
		}
		
	}


<b>Print all subsets using back-tracking</b>

	import java.util.Stack;

	public class AllSubSetsBackTrackingDemo {

		private static Stack<Character> myStack = new Stack<>();
		private static int count = 0;
		private static int iterations = 0;

		public static void main(String[] args) {
			char[] array = {'a','b','c'};

			allSubSets(array, 0);

			System.out.println(myStack.toString());
			System.out.println("Total count " + count);
			System.out.println("Total iterations " + iterations);
		}

		private static void allSubSets(char[] array, int startIndex) { //T(n)
			iterations++;
			if(startIndex == array.length) {
				count++;
				return;
			} else {
				for(int i = startIndex; i < array.length; i++) { // 
					count++;
					myStack.push(array[i]);
					allSubSets(array, i+1); // T(n-1)
					System.out.println(myStack.toString());
					myStack.pop();
				}
			}
		}
	}

<b>Given a set of values, find all possible sum of subsets</b><br>
<b>brute-force</b>

	import java.time.Duration;
	import java.time.Instant;
	import java.util.HashSet;
	import java.util.Set;

	public class SumOfSubsetsBruteForce {

	public static void main(String[] args) {

		int[] list = { 3, 20, 1, 22, 11, 7, 48, 23, 5 ,2, 4, 6, 10, 15, 12, 18, 19, 16, 14, 13, 25, 30, 35, 40, 45, 50};
		Instant start = Instant.now();
		printSubsets(list, 50);
		Instant end = Instant.now();
		Duration duration = Duration.between(start, end);
		System.out.println("Total time taken -> " + duration.getNano());
		System.out.println("Total time taken in seconds-> " + duration.getSeconds());
	}

	static void printSubsets(int[] set, int sum)  { 
		int n = set.length; 
		final Set<Set<Integer>> finalSet = new HashSet<>();
		// Run a loop for printing all 2^n 
		// subsets one by one 
		for (int i = 0; i < (1<<n); i++) {
			//creating 2^n sets
			final Set<Integer> mySet = new HashSet<>();
			int total = 0;
		    // Print current subset
		    setloop:
		    for (int j = 0; j < n; j++) { 
			if ((i & (1 << j)) > 0 ) {
				//It gives all combinations

				//Findout which one suits the sum
				if( total + set[j] <= sum) {
					total = total + set[j];
					mySet.add(set[j]);
				} else {
				break setloop;
				}
			}
		    }

		    if(total == sum) {
			finalSet.add(mySet);

		    }
		}

		for(Set<Integer> match: finalSet) {
			System.out.println("match -> " + match);
		}



		System.out.println(" no of matches " + finalSet.size());
	    } 

	}

<b>Back-tracking</b>

	import java.util.Stack;

	public class AllSubSetsBackTrackingDemo {

		private static Stack<Character> myStack = new Stack<>();
		private static int count = 0;
		private static int iterations = 0;

		public static void main(String[] args) {
			char[] array = {'a','b','c'};

			allSubSets(array, 0);

			System.out.println(myStack.toString());
			System.out.println("Total count " + count);
			System.out.println("Total iterations " + iterations);
		}

		private static void allSubSets(char[] array, int startIndex) { //T(n)
			iterations++;
			if(startIndex == array.length) {
				count++;
				return;
			} else {
				for(int i = startIndex; i < array.length; i++) { // 
					count++;
					myStack.push(array[i]);
					allSubSets(array, i+1); // T(n-1)
					System.out.println(myStack.toString());
					myStack.pop();
				}
			}
		}

	}
